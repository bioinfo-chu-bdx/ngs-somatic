/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.28 from the
 * contents of HTS.xs. Do not edit this file, edit HTS.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "lib/Bio/DB/HTS.xs"
/*
Copyright [2015-2017] EMBL-European Bioinformatics Institute

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#ifdef PERL_CAPI
#define WIN32IO_IS_STDIO
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#ifdef FCGI
 #include <fcgi_stdio.h>
#else
 #ifdef USE_SFIO
  #include <config.h>
 #else
  #include <stdio.h>
 #endif
 #include <perlio.h>
#endif

#ifndef Newx
#  define Newx(v,n,t) New(0,v,n,t)
#endif

#ifndef Newxz
#  define Newxz(v,n,t) Newz(0,v,n,t)
#endif

#include <unistd.h>
#include <math.h>
#include <string.h>
#include "kseq.h"
#include "hts.h"
#include "hfile.h"
#include "sam.h"
#include "khash.h"
#include "faidx.h"
#include "tbx.h"
#include "bgzf.h"
#include "vcf.h"
#include "vcfutils.h"
#include "vcf_sweep.h"
#include "synced_bcf_reader.h"
#include <zlib.h>

/* stolen from bam_aux.c */
#define BAM_MAX_REGION 1<<29

typedef htsFile*        Bio__DB__HTSfile;
typedef bam_hdr_t*      Bio__DB__HTS__Header;
typedef bam1_t*         Bio__DB__HTS__Alignment;
typedef hts_idx_t*      Bio__DB__HTS__Index;
typedef faidx_t*        Bio__DB__HTS__Fai;
typedef bam_pileup1_t*  Bio__DB__HTS__Pileup;
typedef tbx_t*          Bio__DB__HTS__Tabix;
typedef hts_itr_t*      Bio__DB__HTS__Tabix__Iterator;
typedef vcfFile*        Bio__DB__HTS__VCFfile;
typedef bcf_hdr_t*      Bio__DB__HTS__VCF__Header;
typedef bcf_hdr_t*      Bio__DB__HTS__VCF__HeaderPtr;
typedef bcf1_t*         Bio__DB__HTS__VCF__Row;
typedef bcf1_t*         Bio__DB__HTS__VCF__RowPtr;
KSEQ_INIT(gzFile, gzread)
typedef gzFile          Bio__DB__HTS__Kseq;
typedef kseq_t*         Bio__DB__HTS__Kseq__Iterator;
typedef kstream_t*      Bio__DB__HTS__Kseq__Kstream;
typedef kstring_t*      Bio__DB__HTS__Kseq__Kstring;
typedef bcf_sweep_t*    Bio__DB__HTS__VCF__Sweep;

typedef struct {
  SV* callback;
  SV* data;
} fetch_callback_data;
typedef fetch_callback_data *fetch_callback_dataptr;
typedef struct {
  int    start;
  int    end;
  double width;
  int    reads;
  int*   bin;
} coverage_graph;
typedef coverage_graph *coverage_graph_ptr;

static int MaxPileupCnt=8000;

void XS_pack_charPtrPtr( SV * arg, char ** array, int count) {
  int i;
  AV * avref;
  avref = (AV*)sv_2mortal((SV*)newAV());
  for (i=0; i<count; i++) {
    av_push(avref, newSVpv(array[i], strlen(array[i])));
  }
  SvSetSV( arg, newRV((SV*)avref));
}

int hts_fetch_fun (void *data, bam1_t *b)
{
  dSP;
  int count;

  fetch_callback_dataptr fcp;
  SV* callback;
  SV* callbackdata;
  SV* alignment_obj;
  bam1_t *b2;

  fcp          = (fetch_callback_dataptr) data;
  callback     = fcp->callback;
  callbackdata = fcp->data;

  /* turn the bam1_t into an appropriate object */
  /* need to dup it here so that the C layer doesn't reuse the address under Perl */
  b2 = bam_dup1(b);

  alignment_obj = sv_setref_pv(newSV(sizeof(bam1_t)),"Bio::DB::HTS::Alignment",(void*) b2);

  /* set up subroutine stack for the call */
  ENTER;
  SAVETMPS;

  PUSHMARK(SP);
  XPUSHs(sv_2mortal(alignment_obj));
  XPUSHs(callbackdata);
  PUTBACK;

  /* execute the call */
  count = call_sv(callback,G_SCALAR|G_DISCARD);

  FREETMPS;
  LEAVE;

  return 1;
}

int invoke_pileup_callback_fun(uint32_t tid,
			       uint32_t pos,
			       int n,
			       const bam_pileup1_t *pl,
			       void *data) {
  dSP;
  int count,i;
  fetch_callback_dataptr fcp;
  SV*  callback;
  SV*  callbackdata;
  SV*  pileup_obj;
  SV* p;
  SV** pileups;
  AV*  pileup;

  fcp          = (fetch_callback_dataptr) data;
  callback     = fcp->callback;
  callbackdata = fcp->data;

  /* turn the bam_pileup1_t into the appropriate object */
  /* this causes a compiler warning -- ignore it */
  pileup = newAV();
  av_extend(pileup,n);
  for (i=0;i<n;i++) {
    p = newSV(sizeof(bam_pileup1_t));
    sv_setref_pv(p,"Bio::DB::HTS::Pileup",(void*) &pl[i]);
    av_push(pileup,p);
  }

  /* set up subroutine stack for the call */
  ENTER;
  SAVETMPS;

  PUSHMARK(SP);
  XPUSHs(sv_2mortal(newSViv(tid)));
  XPUSHs(sv_2mortal(newSViv(pos)));
  XPUSHs(sv_2mortal(newRV_noinc((SV*)pileup)));
  XPUSHs(callbackdata);
  PUTBACK;

  /* execute the call */
  count = call_sv(callback,G_SCALAR|G_DISCARD);

  FREETMPS;
  LEAVE;
}

/*
   Declarations to allow add_pileup_line to work
   Ported from samtoosl v1 setup.
*/

/* start pileup support copy from bam.h in samtools */
/* but pileup functions are offered as bam_plp_auto_f in htslib */

typedef int (*bam_pileup_f)(uint32_t tid, uint32_t pos, int n, const bam_pileup1_t *pl, void *data);

typedef struct
{
  bam_plp_t iter;
  bam_pileup_f func;
  void *data;
} hts_plbuf_t;


hts_plbuf_t *hts_plbuf_init(bam_pileup_f func, void *data)
{
    hts_plbuf_t *buf;
    buf = calloc(1, sizeof(hts_plbuf_t));
    buf->iter = bam_plp_init(0, 0);
    buf->func = func;
    buf->data = data;
    return buf;
}

void hts_plbuf_destroy(hts_plbuf_t *buf)
{
    bam_plp_destroy(buf->iter);
    free(buf);
}

int hts_plbuf_push(const bam1_t *b, hts_plbuf_t *buf)
{
    int ret, n_plp, tid, pos;
    const bam_pileup1_t *plp;
    ret = bam_plp_push(buf->iter, b);
    if (ret < 0) return ret;
    while ((plp = bam_plp_next(buf->iter, &tid, &pos, &n_plp)) != 0)
        buf->func(tid, pos, n_plp, plp, buf->data);
    return 0;
}


/* end pileup support copy from bam.h in samtools */

/**
   pileup support functions
*/
int add_pileup_line (void *data, bam1_t *b)
{
  hts_plbuf_t *pileup = (hts_plbuf_t*) data;
  hts_plbuf_push(b,pileup);
  return 0;
}



int coverage_from_pileup_fun (uint32_t tid,
			      uint32_t pos,
			      int n,
			      const bam_pileup1_t *pl,
			      void *data) {
  coverage_graph_ptr  cgp;
  int                 bin;
  int                 i;
  int                 valid;

  cgp = (coverage_graph_ptr) data;
  cgp->reads += n;

  valid = 0;
  for (i=0;i<n;i++) {
    if (!pl[i].is_del && !pl[i].is_refskip)
        valid++;
  }

  if (pos >= cgp->start && pos <= cgp->end) {
    bin = (pos-cgp->start)/cgp->width;
    cgp->bin[bin] += valid;
  }

  return 0;
}


/**
   From bam_aux.c in samtools. Needed to allow pileup function to work.
*/
int bam_parse_region(bam_hdr_t *header, const char *str, int *ref_id, int *beg, int *end)
{
    const char *name_lim = hts_parse_reg(str, beg, end);
    if (name_lim) {
        char *name = malloc(name_lim - str + 1);
        memcpy(name, str, name_lim - str);
        name[name_lim - str] = '\0';
        *ref_id = bam_name2id(header, name);
        free(name);
    }
    else {
        // not parsable as a region, but possibly a sequence named "foo:a"
        *ref_id = bam_name2id(header, str);
        *beg = 0; *end = INT_MAX;
    }
    if (*ref_id == -1) return -1;
    return *beg <= *end? 0 : -1;
}

/**
   From bam.c in samtools - these are wrappers that can be used OK here.
*/
char *bam_format1(const bam_hdr_t *header, const bam1_t *b)
{
    kstring_t str;
    str.l = str.m = 0; str.s = NULL;
    sam_format1(header, b, &str);
    return str.s;
}


void bam_view1(const bam_hdr_t *header, const bam1_t *b)
{
        char *s = bam_format1(header, b);
        puts(s);
        free(s);
}


/**
   Get the file extension for a filename
*/
int get_index_fmt_from_extension(const char * filename)
{
  char * ext = strrchr( filename, '.' ) ;
  if( strcmp(ext, ".cram")==0 )
  {
    return HTS_FMT_CRAI ;
  }
  if( strcmp(ext, ".bam")==0 )
  {
    return HTS_FMT_BAI ; //could also be HTS_FMT_CSI
  }
  return -1 ;
}

/**
   fetch function
*/
int hts_fetch(htsFile *fp, const hts_idx_t *idx, int tid, int beg, int end, void *data, bam_plp_auto_f func)
{
    int ret;
    hts_itr_t *iter ;
    bam1_t *b ;

    iter = sam_itr_queryi(idx, tid, beg, end);
    b = bam_init1();

    while((ret = sam_itr_next(fp, iter, b)) >= 0)
    {
        func(data,b);
    }
    hts_itr_destroy(iter);
    bam_destroy1(b);
    return (ret == -1)? 0 : ret;
}


#line 373 "lib/Bio/DB/HTS.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 517 "lib/Bio/DB/HTS.c"

XS_EUPXS(XS_Bio__DB__HTS__Fai_load); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Fai_load)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "packname=\"Bio::DB::HTS::Fai\", filename");
    {
	char *	packname;
	char *	filename = (char *)SvPV_nolen(ST(1))
;
	Bio__DB__HTS__Fai	RETVAL;

	if (items < 1)
	    packname = "Bio::DB::HTS::Fai";
	else {
	    packname = (char *)SvPV_nolen(ST(0))
;
	}
#line 371 "lib/Bio/DB/HTS.xs"
    RETVAL = fai_load(filename);
#line 539 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Fai", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Fai_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Fai_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "fai");
    {
	Bio__DB__HTS__Fai	fai;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    fai = INT2PTR(Bio__DB__HTS__Fai,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"Bio::DB::HTS::Fai::DESTROY",
			"fai")
;
#line 380 "lib/Bio/DB/HTS.xs"
    fai_destroy(fai);
#line 571 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Fai_fetch); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Fai_fetch)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "fai, reg");
    {
	Bio__DB__HTS__Fai	fai;
	const char *	reg = (const char *)SvPV_nolen(ST(1))
;
#line 388 "lib/Bio/DB/HTS.xs"
    char     *seq;
    int       len;
#line 590 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Fai")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    fai = INT2PTR(Bio__DB__HTS__Fai,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Fai::fetch",
			"fai", "Bio::DB::HTS::Fai")
;
#line 391 "lib/Bio/DB/HTS.xs"
    seq = fai_fetch(fai,reg,&len);
    if (seq == NULL)
       XSRETURN_EMPTY;
    RETVAL = newSVpv(seq,len);
    free((void*)seq);
#line 608 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTSfile_max_pileup_cnt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_max_pileup_cnt)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "packname, ...");
    {
	int	RETVAL;
	dXSTARG;
#line 405 "lib/Bio/DB/HTS.xs"
	if (items > 1)
	   MaxPileupCnt = SvIV(ST(1));
	RETVAL = MaxPileupCnt;
#line 629 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTSfile_is_remote); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_is_remote)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "packname, filename");
    {
	char *	packname = (char *)SvPV_nolen(ST(0))
;
	char *	filename = (char *)SvPV_nolen(ST(1))
;
	int	RETVAL;
	dXSTARG;
#line 418 "lib/Bio/DB/HTS.xs"
        RETVAL = hisremote(filename) ;
#line 651 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTSfile_open); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_open)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "packname, filename, mode=\"r\"");
    {
	char *	packname = (char *)SvPV_nolen(ST(0))
;
	char *	filename = (char *)SvPV_nolen(ST(1))
;
	char *	mode;
	Bio__DB__HTSfile	RETVAL;

	if (items < 3)
	    mode = "r";
	else {
	    mode = (char *)SvPV_nolen(ST(2))
;
	}
#line 432 "lib/Bio/DB/HTS.xs"
        RETVAL = hts_open(filename,mode);
#line 680 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTSfile", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTSfile_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "htsfile");
    {
	Bio__DB__HTSfile	htsfile;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    htsfile = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"Bio::DB::HTSfile::DESTROY",
			"htsfile")
;
#line 442 "lib/Bio/DB/HTS.xs"
   hts_close(htsfile);
#line 712 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTSfile_index_build); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_index_build)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "packname, filename");
    {
	char *	packname = (char *)SvPV_nolen(ST(0))
;
	const char *	filename = (const char *)SvPV_nolen(ST(1))
;
	int	RETVAL;
	dXSTARG;
#line 450 "lib/Bio/DB/HTS.xs"
     RETVAL = sam_index_build(filename,0); //generate BAI for BAM files
#line 733 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTSfile_index_load); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_index_load)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "packname, htsfile");
    {
	char *	packname = (char *)SvPV_nolen(ST(0))
;
	Bio__DB__HTSfile	htsfile;
	Bio__DB__HTS__Index	RETVAL;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    htsfile = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTSfile::index_load",
			"htsfile", "Bio::DB::HTSfile")
;
#line 460 "lib/Bio/DB/HTS.xs"
      RETVAL = sam_index_load(htsfile, htsfile->fn) ;
#line 763 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Index", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTSfile_header_read); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_header_read)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "htsfile");
    {
	Bio__DB__HTSfile	htsfile;
#line 469 "lib/Bio/DB/HTS.xs"
      bam_hdr_t *bh;
      int64_t result ;
      const htsFormat *format ;
#line 787 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__Header	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    htsfile = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTSfile::header_read",
			"htsfile", "Bio::DB::HTSfile")
;
#line 473 "lib/Bio/DB/HTS.xs"
      format = hts_get_format( htsfile ) ;
      if( format->format == bam ) //enum value from htsExactFormat from hts.h
      {
        result = bgzf_seek(htsfile->fp.bgzf,0,0) ;
      }
      bh = sam_hdr_read(htsfile);
      RETVAL = bh ;
#line 807 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Header", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTSfile_header_write); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_header_write)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "htsfile, header, ...");
    {
	Bio__DB__HTSfile	htsfile;
	Bio__DB__HTS__Header	header;
#line 489 "lib/Bio/DB/HTS.xs"
      char *reference = "";
      const htsFormat *format ;
#line 831 "lib/Bio/DB/HTS.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    htsfile = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTSfile::header_write",
			"htsfile", "Bio::DB::HTSfile")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTSfile::header_write",
			"header", "Bio::DB::HTS::Header")
;
#line 493 "lib/Bio/DB/HTS.xs"
      format = hts_get_format( htsfile ) ;
      if( format->format == cram )
      {
        if(items > 2)
        {
          reference = (char *)SvPV_nolen(ST(2));
          hts_set_fai_filename(htsfile, reference);
        }
        else
        {
          croak("Error: need reference sequence file for writing CRAM file '%s'", htsfile->fn);
        }
      }
      RETVAL= sam_hdr_write(htsfile,header);
      if (RETVAL != 0)
        croak("Error %d while creating file '%s'", RETVAL, htsfile->fn);
#line 871 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTSfile_read1); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_read1)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "htsfile, header");
    {
	Bio__DB__HTSfile	htsfile;
	Bio__DB__HTS__Header	header;
#line 518 "lib/Bio/DB/HTS.xs"
    bam1_t *alignment;
#line 889 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__Alignment	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    htsfile = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTSfile::read1",
			"htsfile", "Bio::DB::HTSfile")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTSfile::read1",
			"header", "Bio::DB::HTS::Header")
;
#line 520 "lib/Bio/DB/HTS.xs"
       alignment = bam_init1();
       if (sam_read1(htsfile,header,alignment) >= 0) {
         RETVAL = alignment ;
       }
       else
         XSRETURN_EMPTY;
#line 918 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Alignment", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTSfile_write1); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_write1)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "htsfile, header, align");
    {
	Bio__DB__HTSfile	htsfile;
	Bio__DB__HTS__Header	header;
	Bio__DB__HTS__Alignment	align;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    htsfile = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTSfile::write1",
			"htsfile", "Bio::DB::HTSfile")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTSfile::write1",
			"header", "Bio::DB::HTS::Header")
;

	if (SvROK(ST(2)) && sv_derived_from(ST(2), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    align = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTSfile::write1",
			"align", "Bio::DB::HTS::Alignment")
;
#line 536 "lib/Bio/DB/HTS.xs"
      RETVAL = sam_write1(htsfile,header,align);
#line 974 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_new)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "package=\"Bio::DB::HTS::Alignment\"");
    {
	char *	package;
	Bio__DB__HTS__Alignment	RETVAL;

	if (items < 1)
	    package = "Bio::DB::HTS::Alignment";
	else {
	    package = (char *)SvPV_nolen(ST(0))
;
	}
#line 547 "lib/Bio/DB/HTS.xs"
      RETVAL = bam_init1();
#line 999 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Alignment", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"Bio::DB::HTS::Alignment::DESTROY",
			"b")
;
#line 556 "lib/Bio/DB/HTS.xs"
    bam_destroy1(b);
#line 1031 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_tid); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_tid)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::tid",
			"b", "Bio::DB::HTS::Alignment")
;
#line 563 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.tid = SvIV(ST(1));
    RETVAL=b->core.tid;
#line 1061 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_pos); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_pos)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::pos",
			"b", "Bio::DB::HTS::Alignment")
;
#line 574 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.pos = SvIV(ST(1));
    RETVAL=b->core.pos;
#line 1092 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_calend); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_calend)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::calend",
			"b", "Bio::DB::HTS::Alignment")
;
#line 585 "lib/Bio/DB/HTS.xs"
   RETVAL=bam_endpos(b);
#line 1121 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_cigar2qlen); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_cigar2qlen)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::cigar2qlen",
			"b", "Bio::DB::HTS::Alignment")
;
#line 594 "lib/Bio/DB/HTS.xs"
   RETVAL=bam_cigar2qlen(b->core.n_cigar,bam_get_cigar(b));
#line 1150 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_qual); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_qual)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::qual",
			"b", "Bio::DB::HTS::Alignment")
;
#line 603 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.qual = SvIV(ST(1));
    RETVAL=b->core.qual;
#line 1181 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_flag); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_flag)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::flag",
			"b", "Bio::DB::HTS::Alignment")
;
#line 614 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.flag = SvIV(ST(1));
    RETVAL=b->core.flag;
#line 1212 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_n_cigar); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_n_cigar)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::n_cigar",
			"b", "Bio::DB::HTS::Alignment")
;
#line 625 "lib/Bio/DB/HTS.xs"
  if (items > 1)
    b->core.n_cigar = SvIV(ST(1));
    RETVAL=b->core.n_cigar;
#line 1243 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_l_qseq); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_l_qseq)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::l_qseq",
			"b", "Bio::DB::HTS::Alignment")
;
#line 636 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.l_qseq = SvIV(ST(1));
    RETVAL=b->core.l_qseq;
#line 1274 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_qseq); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_qseq)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
#line 647 "lib/Bio/DB/HTS.xs"
    char* seq;
    int   i;
#line 1292 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::qseq",
			"b", "Bio::DB::HTS::Alignment")
;
#line 650 "lib/Bio/DB/HTS.xs"
    seq = Newxz(seq,b->core.l_qseq+1,char);
    for (i=0;i<b->core.l_qseq;i++) {
      seq[i]=seq_nt16_str[bam_seqi(bam_get_seq(b),i)];
    }
    RETVAL = newSVpv(seq,b->core.l_qseq);
    Safefree(seq);
#line 1311 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment__qscore); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment__qscore)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::_qscore",
			"b", "Bio::DB::HTS::Alignment")
;
#line 664 "lib/Bio/DB/HTS.xs"
    RETVAL = newSVpv(bam_get_qual(b),b->core.l_qseq);
#line 1340 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_mtid); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_mtid)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::mtid",
			"b", "Bio::DB::HTS::Alignment")
;
#line 673 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.mtid = SvIV(ST(1));
    RETVAL=b->core.mtid;
#line 1372 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_mpos); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_mpos)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::mpos",
			"b", "Bio::DB::HTS::Alignment")
;
#line 684 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.mpos = SvIV(ST(1));
    RETVAL=b->core.mpos;
#line 1403 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_isize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_isize)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::isize",
			"b", "Bio::DB::HTS::Alignment")
;
#line 695 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.isize = SvIV(ST(1));
    RETVAL=b->core.isize;
#line 1434 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_l_aux); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_l_aux)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::l_aux",
			"b", "Bio::DB::HTS::Alignment")
;
#line 706 "lib/Bio/DB/HTS.xs"
    RETVAL=SvIV(newSViv(bam_get_l_aux(b)));
#line 1463 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_aux); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_aux)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
#line 714 "lib/Bio/DB/HTS.xs"
   uint8_t *s;
   uint8_t type, key[2];
   char    str[8192];
#line 1482 "lib/Bio/DB/HTS.c"
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::aux",
			"b", "Bio::DB::HTS::Alignment")
;
#line 718 "lib/Bio/DB/HTS.xs"
   s = bam_get_aux(b);
   str[0] = '\0';

   int left  = sizeof(str) - strlen(str);
   while (left > 0 && (s < b->data + b->l_data)) {
        char* d   = str+strlen(str);

	key[0] = s[0];
	key[1] = s[1];
 	left -= snprintf(d, left, "%c%c:", key[0], key[1]);

	d    += 3;
	s    += 2;
	type = *s++;

	if (left <= 0) continue;

	if (type == 'A')      { left -= snprintf(d, left, "A:%c", *s);           s++; }
	else if (type == 'C') { left -= snprintf(d, left, "i:%u", *s);           s++; }
	else if (type == 'c') { left -= snprintf(d, left, "i:%d", *s);           s++; }
	else if (type == 'S') { left -= snprintf(d, left, "i:%u", *(uint16_t*)s);s += 2; }
	else if (type == 's') { left -= snprintf(d, left, "i:%d", *(int16_t*)s); s += 2; }
	else if (type == 'I') { left -= snprintf(d, left, "i:%u", *(uint32_t*)s);s += 4; }
	else if (type == 'i') { left -= snprintf(d, left, "i:%d", *(int32_t*)s); s += 4; }
	else if (type == 'f') { left -= snprintf(d, left, "f:%g", *(float*)s);   s += 4; }
	else if (type == 'd') { left -= snprintf(d, left, "d:%lg", *(double*)s); s += 8; }
	else if (type == 'Z' || type == 'H') { left -= snprintf(d, left, "%c:", type);
	                                       strncat(d,s,left);
					       while (*s++) {}
					       left = sizeof(str) - strlen(str);
	                                     }
	if (left <= 0) continue;
	strncat(d,"\t",left);
	left--;
   }
   str[strlen(str)-1] = '\0';
   RETVAL = str;
#line 1533 "lib/Bio/DB/HTS.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_aux_get); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_aux_get)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b, tag");
    {
	Bio__DB__HTS__Alignment	b;
	char*	tag = (char *)SvPV_nolen(ST(1))
;
#line 764 "lib/Bio/DB/HTS.xs"
   int           type;
   uint8_t       *s;
#line 1553 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::aux_get",
			"b", "Bio::DB::HTS::Alignment")
;
#line 767 "lib/Bio/DB/HTS.xs"
   s    = bam_aux_get(b,tag);
   if (s==0)
      XSRETURN_EMPTY;
   type = *s++;
   switch (type) {
   case 'c':
     RETVAL = newSViv((int32_t)*(int8_t*)s);
     break;
   case 'C':
     RETVAL = newSViv((int32_t)*(uint8_t*)s);
     break;
   case 's':
     RETVAL = newSViv((int32_t)*(int16_t*)s);
     break;
   case 'S':
     RETVAL = newSViv((int32_t)*(uint16_t*)s);
     break;
   case 'i':
     RETVAL = newSViv(*(int32_t*)s);
     break;
   case 'I':
     RETVAL = newSViv((int32_t)*(uint32_t*)s);
     break;
   case 'f':
     RETVAL = newSVnv(*(float*)s);
     break;
   case 'Z':
   case 'H':
     RETVAL = newSVpv((char*)s,0);
     break;
   case 'A':
     RETVAL = newSVpv((char*)s,1);
     break;
   default:
     XSRETURN_EMPTY;
   }
#line 1602 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_aux_keys); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_aux_keys)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Bio__DB__HTS__Alignment	b;
#line 811 "lib/Bio/DB/HTS.xs"
   uint8_t *s;
   uint8_t type;
#line 1623 "lib/Bio/DB/HTS.c"

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::aux_keys",
			"b", "Bio::DB::HTS::Alignment")
;
#line 814 "lib/Bio/DB/HTS.xs"
   {
     s = bam_get_aux(b);  /* s is a khash macro */
     while (s < b->data + b->l_data) {
       XPUSHs(sv_2mortal(newSVpv(s,2)));
       s   += 2;
       type = *s++;
       if      (type == 'A') { ++s; }
       else if (type == 'C') { ++s; }
       else if (type == 'c') { ++s; }
       else if (type == 'S') { s += 2; }
       else if (type == 's') { s += 2; }
       else if (type == 'I') { s += 4; }
       else if (type == 'i') { s += 4; }
       else if (type == 'f') { s += 4; }
       else if (type == 'Z' || type == 'H') { while (*s) ++(s); ++(s); }
     }
   }
#line 1652 "lib/Bio/DB/HTS.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_data); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_data)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
#line 837 "lib/Bio/DB/HTS.xs"
    STRLEN  len;
#line 1669 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::data",
			"b", "Bio::DB::HTS::Alignment")
;
#line 839 "lib/Bio/DB/HTS.xs"
    if (items > 1) {
      b->data     = SvPV(ST(1),len);
      b->l_data = len;
    }
    RETVAL=newSVpv(b->data,b->l_data);
#line 1687 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_data_len); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_data_len)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::data_len",
			"b", "Bio::DB::HTS::Alignment")
;
#line 852 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->l_data = SvIV(ST(1));
    RETVAL=b->l_data;
#line 1719 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_m_data); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_m_data)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::m_data",
			"b", "Bio::DB::HTS::Alignment")
;
#line 863 "lib/Bio/DB/HTS.xs"
    if (items > 1) {
      b->m_data = SvIV(ST(1));
    }
    RETVAL=b->m_data;
#line 1751 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_qname); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_qname)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::qname",
			"b", "Bio::DB::HTS::Alignment")
;
#line 875 "lib/Bio/DB/HTS.xs"
    RETVAL=newSVpv(bam_get_qname(b),0);
#line 1779 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_paired); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_paired)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::paired",
			"b", "Bio::DB::HTS::Alignment")
;
#line 884 "lib/Bio/DB/HTS.xs"
    RETVAL=(b->core.flag&BAM_FPAIRED) != 0;
#line 1809 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_proper_pair); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_proper_pair)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::proper_pair",
			"b", "Bio::DB::HTS::Alignment")
;
#line 893 "lib/Bio/DB/HTS.xs"
    RETVAL=(b->core.flag&BAM_FPROPER_PAIR) != 0;
#line 1838 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_unmapped); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_unmapped)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::unmapped",
			"b", "Bio::DB::HTS::Alignment")
;
#line 902 "lib/Bio/DB/HTS.xs"
    RETVAL=(b->core.flag&BAM_FUNMAP) != 0;
#line 1867 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_munmapped); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_munmapped)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::munmapped",
			"b", "Bio::DB::HTS::Alignment")
;
#line 911 "lib/Bio/DB/HTS.xs"
    RETVAL=(b->core.flag&BAM_FMUNMAP) != 0;
#line 1896 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_reversed); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_reversed)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::reversed",
			"b", "Bio::DB::HTS::Alignment")
;
#line 920 "lib/Bio/DB/HTS.xs"
  RETVAL=bam_is_rev(b);
#line 1925 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_mreversed); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_mreversed)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::mreversed",
			"b", "Bio::DB::HTS::Alignment")
;
#line 929 "lib/Bio/DB/HTS.xs"
  RETVAL=bam_is_mrev(b);
#line 1954 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_cigar); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_cigar)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
#line 938 "lib/Bio/DB/HTS.xs"
    int        i;
    uint32_t  *c;
    AV        *avref;
#line 1973 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::cigar",
			"b", "Bio::DB::HTS::Alignment")
;
#line 942 "lib/Bio/DB/HTS.xs"
    avref = (AV*) sv_2mortal((SV*)newAV());
    c     = bam_get_cigar(b);
    for (i=0;i<b->core.n_cigar;i++)
      av_push(avref, newSViv(c[i]));
    RETVAL = (SV*) newRV((SV*)avref);
#line 1991 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Header_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Header_new)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "packname=Bio::DB::HTS::Header");
    {
	Bio__DB__HTS__Header	RETVAL;
#line 956 "lib/Bio/DB/HTS.xs"
    RETVAL = bam_hdr_init();
#line 2009 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Header", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Header_n_targets); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Header_n_targets)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "bamh");
    {
	Bio__DB__HTS__Header	bamh;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Header::n_targets",
			"bamh", "Bio::DB::HTS::Header")
;
#line 965 "lib/Bio/DB/HTS.xs"
    RETVAL = bamh->n_targets;
#line 2043 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Header_target_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Header_target_name)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "bamh");
    {
	Bio__DB__HTS__Header	bamh;
#line 974 "lib/Bio/DB/HTS.xs"
    int i;
    AV * avref;
#line 2061 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Header::target_name",
			"bamh", "Bio::DB::HTS::Header")
;
#line 977 "lib/Bio/DB/HTS.xs"
    avref = (AV*) sv_2mortal((SV*)newAV());
    for (i=0;i<bamh->n_targets;i++)
      av_push(avref, newSVpv(bamh->target_name[i],0));
    RETVAL = (SV*) newRV((SV*)avref);
#line 2078 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Header_target_len); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Header_target_len)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "bamh");
    {
	Bio__DB__HTS__Header	bamh;
#line 989 "lib/Bio/DB/HTS.xs"
    int i;
    AV * avref;
#line 2097 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Header::target_len",
			"bamh", "Bio::DB::HTS::Header")
;
#line 992 "lib/Bio/DB/HTS.xs"
    avref = (AV*) sv_2mortal((SV*)newAV());
    for (i=0;i<bamh->n_targets;i++)
       av_push(avref, newSViv(bamh->target_len[i]));
    RETVAL = (SV*) newRV((SV*)avref);
#line 2114 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Header_text); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Header_text)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "bamh, ...");
    {
	Bio__DB__HTS__Header	bamh;
#line 1003 "lib/Bio/DB/HTS.xs"
    char   *newtext;
    STRLEN n;
#line 2133 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Header::text",
			"bamh", "Bio::DB::HTS::Header")
;
#line 1006 "lib/Bio/DB/HTS.xs"
    /* in case text is not null terminated, we copy it */
    RETVAL = newSVpv(bamh->text,bamh->l_text);
    if (items > 1) {
      newtext = (char*) SvPV(ST(1),n);
      strcpy(bamh->text,newtext);
      bamh->l_text = n;
    }
#line 2153 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Header_parse_region); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Header_parse_region)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "bamh, region");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Bio__DB__HTS__Header	bamh;
	char*	region = (char *)SvPV_nolen(ST(1))
;
#line 1023 "lib/Bio/DB/HTS.xs"
       int seqid,start,end;
#line 2175 "lib/Bio/DB/HTS.c"

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Header::parse_region",
			"bamh", "Bio::DB::HTS::Header")
;
#line 1025 "lib/Bio/DB/HTS.xs"
    {
      bam_parse_region(bamh,
		       region,
		       &seqid,
		       &start,
		       &end);
      if (seqid < 0)
	XSRETURN_EMPTY;
      else {
	EXTEND(sp,3);
	PUSHs(sv_2mortal(newSViv(seqid)));
	PUSHs(sv_2mortal(newSViv(start)));
	PUSHs(sv_2mortal(newSViv(end)));
      }
    }
#line 2202 "lib/Bio/DB/HTS.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Bio__DB__HTS__Header_view1); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Header_view1)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "bamh, alignment");
    {
	Bio__DB__HTS__Header	bamh;
	Bio__DB__HTS__Alignment	alignment;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Header::view1",
			"bamh", "Bio::DB::HTS::Header")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    alignment = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Header::view1",
			"alignment", "Bio::DB::HTS::Alignment")
;
#line 1047 "lib/Bio/DB/HTS.xs"
       bam_view1(bamh,alignment);
#line 2240 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Header_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Header_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "bamh");
    {
	Bio__DB__HTS__Header	bamh;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"Bio::DB::HTS::Header::DESTROY",
			"bamh")
;
#line 1055 "lib/Bio/DB/HTS.xs"
    bam_hdr_destroy(bamh);
#line 2266 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Index_fetch); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Index_fetch)
{
    dVAR; dXSARGS;
    if (items < 6 || items > 7)
       croak_xs_usage(cv,  "bai, hfp, ref, start, end, callback, callbackdata=&PL_sv_undef");
    {
	Bio__DB__HTS__Index	bai;
	Bio__DB__HTSfile	hfp;
	int	ref = (int)SvIV(ST(2))
;
	int	start = (int)SvIV(ST(3))
;
	int	end = (int)SvIV(ST(4))
;
	CV*	callback;
	SV*	callbackdata;
#line 1071 "lib/Bio/DB/HTS.xs"
  fetch_callback_data fcd;
#line 2291 "lib/Bio/DB/HTS.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Index")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bai = INT2PTR(Bio__DB__HTS__Index,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Index::fetch",
			"bai", "Bio::DB::HTS::Index")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    hfp = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Index::fetch",
			"hfp", "Bio::DB::HTSfile")
;

	STMT_START {
                HV *st;
                GV *gvp;
		SV * const xsub_tmp_sv = ST(5);
		SvGETMAGIC(xsub_tmp_sv);
                callback = sv_2cv(xsub_tmp_sv, &st, &gvp, 0);
		if (!callback) {
		    Perl_croak_nocontext("%s: %s is not a CODE reference",
				"Bio::DB::HTS::Index::fetch",
				"callback");
		}
	} STMT_END
;

	if (items < 7)
	    callbackdata = &PL_sv_undef;
	else {
	    callbackdata = ST(6)
;
	}
#line 1073 "lib/Bio/DB/HTS.xs"
  {
    fcd.callback = (SV*) callback;
    fcd.data     = callbackdata;
    RETVAL = hts_fetch(hfp,bai,ref,start,end,&fcd,hts_fetch_fun);
  }
#line 2341 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Index_pileup); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Index_pileup)
{
    dVAR; dXSARGS;
    if (items < 6 || items > 7)
       croak_xs_usage(cv,  "bai, hfp, ref, start, end, callback, callbackdata=&PL_sv_undef");
    {
	Bio__DB__HTS__Index	bai;
	Bio__DB__HTSfile	hfp;
	int	ref = (int)SvIV(ST(2))
;
	int	start = (int)SvIV(ST(3))
;
	int	end = (int)SvIV(ST(4))
;
	CV*	callback;
	SV*	callbackdata;
#line 1092 "lib/Bio/DB/HTS.xs"
  fetch_callback_data fcd;
  hts_plbuf_t        *pileup;
#line 2368 "lib/Bio/DB/HTS.c"

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Index")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bai = INT2PTR(Bio__DB__HTS__Index,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Index::pileup",
			"bai", "Bio::DB::HTS::Index")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    hfp = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Index::pileup",
			"hfp", "Bio::DB::HTSfile")
;

	STMT_START {
                HV *st;
                GV *gvp;
		SV * const xsub_tmp_sv = ST(5);
		SvGETMAGIC(xsub_tmp_sv);
                callback = sv_2cv(xsub_tmp_sv, &st, &gvp, 0);
		if (!callback) {
		    Perl_croak_nocontext("%s: %s is not a CODE reference",
				"Bio::DB::HTS::Index::pileup",
				"callback");
		}
	} STMT_END
;

	if (items < 7)
	    callbackdata = &PL_sv_undef;
	else {
	    callbackdata = ST(6)
;
	}
#line 1095 "lib/Bio/DB/HTS.xs"
  fcd.callback = (SV*) callback;
  fcd.data     = callbackdata;
  pileup       = hts_plbuf_init(invoke_pileup_callback_fun,(void*)&fcd);
  bam_plp_set_maxcnt(pileup->iter,MaxPileupCnt);
  hts_fetch(hfp,bai,ref,start,end,(void*)pileup,add_pileup_line);
  hts_plbuf_push(NULL,pileup);
  hts_plbuf_destroy(pileup);
#line 2418 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Index_coverage); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Index_coverage)
{
    dVAR; dXSARGS;
    if (items < 5 || items > 7)
       croak_xs_usage(cv,  "bai, hfp, ref, start, end, bins=0, maxcnt=8000");
    {
	Bio__DB__HTS__Index	bai;
	Bio__DB__HTSfile	hfp;
	int	ref = (int)SvIV(ST(2))
;
	int	start = (int)SvIV(ST(3))
;
	int	end = (int)SvIV(ST(4))
;
	int	bins;
	int	maxcnt;
#line 1113 "lib/Bio/DB/HTS.xs"
    coverage_graph  cg;
    hts_plbuf_t    *pileup;
    AV*             array;
    SV*             cov;
    int             i;
    bam_hdr_t      *bh;
    const htsFormat *format ;
#line 2449 "lib/Bio/DB/HTS.c"
	AV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Index")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bai = INT2PTR(Bio__DB__HTS__Index,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Index::coverage",
			"bai", "Bio::DB::HTS::Index")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    hfp = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Index::coverage",
			"hfp", "Bio::DB::HTSfile")
;

	if (items < 6)
	    bins = 0;
	else {
	    bins = (int)SvIV(ST(5))
;
	}

	if (items < 7)
	    maxcnt = 8000;
	else {
	    maxcnt = (int)SvIV(ST(6))
;
	}
#line 1121 "lib/Bio/DB/HTS.xs"
  {
      /* TODO:can we do away with this check by a move to CSI as the standard for BAM indices */
      if (end >= BAM_MAX_REGION)
      {
        format = hts_get_format( hfp ) ;
        if( format->format == bam ) //enum value from htsExactFormat from hts.h
        {
          bgzf_seek(hfp->fp.bgzf,0,0);
          bh = sam_hdr_read(hfp);
          end = bh->target_len[ref];
          bam_hdr_destroy(bh);
        }
      }
      if ((bins==0) || (bins > (end-start)))
         bins = end-start;

      /* coverage graph used to communicate to our callback
	  the region we are sampling */
      cg.start = start;
      cg.end   = end;
      cg.reads = 0;
      cg.width = ((double)(end-start))/bins;
      Newxz(cg.bin,bins+1,int);

      /* accumulate coverage into the coverage graph */
      pileup   = hts_plbuf_init(coverage_from_pileup_fun,(void*)&cg);
      if (items >= 7)
            bam_plp_set_maxcnt(pileup->iter,maxcnt);
      else
            bam_plp_set_maxcnt(pileup->iter,MaxPileupCnt);
      hts_fetch(hfp,bai,ref,start,end,(void*)pileup,add_pileup_line);
      hts_plbuf_push(NULL,pileup);
      hts_plbuf_destroy(pileup);

      /* now normalize to coverage/bp and convert into an array */
      array = newAV();
      av_extend(array,bins);
      for  (i=0;i<bins;i++)
           av_store(array,i,newSVnv(((float)cg.bin[i])/cg.width));
      Safefree(cg.bin);
      RETVAL = array;
      sv_2mortal((SV*)RETVAL);  /* this fixes a documented bug in perl typemap */
  }
#line 2529 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Index_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Index_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "hts_idx");
    {
	Bio__DB__HTS__Index	hts_idx;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hts_idx = INT2PTR(Bio__DB__HTS__Index,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"Bio::DB::HTS::Index::DESTROY",
			"hts_idx")
;
#line 1172 "lib/Bio/DB/HTS.xs"
    hts_idx_destroy(hts_idx) ;
#line 2561 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_qpos); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_qpos)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::qpos",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1182 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->qpos;
#line 2589 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_pos); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_pos)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::pos",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1190 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->qpos+1;
#line 2618 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_indel); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_indel)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::indel",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1198 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->indel;
#line 2647 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_level); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_level)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::level",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1206 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->level;
#line 2676 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_is_del); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_is_del)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::is_del",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1214 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->is_del;
#line 2705 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_is_refskip); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_is_refskip)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::is_refskip",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1222 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->is_refskip;
#line 2734 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_is_head); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_is_head)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::is_head",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1230 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->is_head;
#line 2763 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_is_tail); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_is_tail)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::is_tail",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1238 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->is_tail;
#line 2792 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_b); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_b)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	Bio__DB__HTS__Alignment	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::b",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1246 "lib/Bio/DB/HTS.xs"
    RETVAL = bam_dup1(pl->b);
#line 2820 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Alignment", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_alignment); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_alignment)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	Bio__DB__HTS__Alignment	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::alignment",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1254 "lib/Bio/DB/HTS.xs"
    RETVAL = bam_dup1(pl->b);
#line 2853 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Alignment", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_open); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_open)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "fname");
    {
	char *	fname = (char *)SvPV_nolen(ST(0))
;
	Bio__DB__HTS__Tabix	RETVAL;
#line 1266 "lib/Bio/DB/HTS.xs"
    RETVAL = tbx_index_load(fname);
#line 2877 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Tabix", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_close); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_close)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "t");
    {
	Bio__DB__HTS__Tabix	t;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Tabix")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    t = INT2PTR(Bio__DB__HTS__Tabix,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::tbx_close",
			"t", "Bio::DB::HTS::Tabix")
;
#line 1275 "lib/Bio/DB/HTS.xs"
    tbx_destroy(t);
#line 2909 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_query); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_query)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "t, region");
    {
	Bio__DB__HTS__Tabix	t;
	char *	region = (char *)SvPV_nolen(ST(1))
;
	Bio__DB__HTS__Tabix__Iterator	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Tabix")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    t = INT2PTR(Bio__DB__HTS__Tabix,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::tbx_query",
			"t", "Bio::DB::HTS::Tabix")
;
#line 1282 "lib/Bio/DB/HTS.xs"
    RETVAL = tbx_itr_querys(t, region);
#line 2938 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Tabix::Iterator", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_header); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_header)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "fp, tabix");
    {
	Bio__DB__HTSfile	fp;
	Bio__DB__HTS__Tabix	tabix;
#line 1293 "lib/Bio/DB/HTS.xs"
    int num_header_lines = 0;
    AV *av_ref;
    kstring_t str = {0,0,0};
#line 2963 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    fp = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::tbx_header",
			"fp", "Bio::DB::HTSfile")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::Tabix")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    tabix = INT2PTR(Bio__DB__HTS__Tabix,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::tbx_header",
			"tabix", "Bio::DB::HTS::Tabix")
;
#line 1297 "lib/Bio/DB/HTS.xs"
    av_ref = newAV();
    while ( hts_getline(fp, KS_SEP_LINE, &str) >= 0 ) {
        if ( ! str.l ) break; //no lines left so we are done
        if ( str.s[0] != tabix->conf.meta_char ) break;

        //the line begins with a # so add it to the array
        ++num_header_lines;
        av_push(av_ref, newSVpv(str.s, str.l));
    }

    if ( ! num_header_lines )
        XSRETURN_EMPTY;

    RETVAL = newRV_noinc((SV*) av_ref);
    free(str.s);
#line 3001 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_seqnames); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_seqnames)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "t");
    {
	Bio__DB__HTS__Tabix	t;
#line 1319 "lib/Bio/DB/HTS.xs"
    const char **names;
    int i, num_seqs;
    AV *av_ref;
#line 3021 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Tabix")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    t = INT2PTR(Bio__DB__HTS__Tabix,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::tbx_seqnames",
			"t", "Bio::DB::HTS::Tabix")
;
#line 1323 "lib/Bio/DB/HTS.xs"
    names = tbx_seqnames(t, &num_seqs); //call actual tabix method

    //blast all the values onto a perl array
    av_ref = newAV();
    for (i = 0; i < num_seqs; ++i) {
        SV *sv_ref = newSVpv(names[i], 0);
        av_push(av_ref, sv_ref);
    }

    free(names);

    //return a reference to our array
    RETVAL = newRV_noinc((SV*)av_ref);
#line 3047 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Tabix__Iterator_tbx_iter_next); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Tabix__Iterator_tbx_iter_next)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "iter, fp, t");
    {
	Bio__DB__HTS__Tabix__Iterator	iter;
	Bio__DB__HTSfile	fp;
	Bio__DB__HTS__Tabix	t;
#line 1347 "lib/Bio/DB/HTS.xs"
    kstring_t str = {0,0,0};
#line 3067 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Tabix::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    iter = INT2PTR(Bio__DB__HTS__Tabix__Iterator,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::Iterator::tbx_iter_next",
			"iter", "Bio::DB::HTS::Tabix::Iterator")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    fp = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::Iterator::tbx_iter_next",
			"fp", "Bio::DB::HTSfile")
;

	if (SvROK(ST(2)) && sv_derived_from(ST(2), "Bio::DB::HTS::Tabix")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    t = INT2PTR(Bio__DB__HTS__Tabix,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::Iterator::tbx_iter_next",
			"t", "Bio::DB::HTS::Tabix")
;
#line 1349 "lib/Bio/DB/HTS.xs"
    if (tbx_itr_next(fp, t, iter, &str) < 0) {
        free(str.s);
        XSRETURN_EMPTY;
    }

    RETVAL = newSVpv(str.s, str.l);
    free(str.s);

#line 3108 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Tabix__Iterator_tbx_iter_free); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Tabix__Iterator_tbx_iter_free)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "iter");
    {
	Bio__DB__HTS__Tabix__Iterator	iter;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Tabix::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    iter = INT2PTR(Bio__DB__HTS__Tabix__Iterator,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::Iterator::tbx_iter_free",
			"iter", "Bio::DB::HTS::Tabix::Iterator")
;
#line 1364 "lib/Bio/DB/HTS.xs"
	tbx_itr_destroy(iter);
#line 3136 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__VCFfile_open); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCFfile_open)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "packname, filename, mode=\"r\"");
    {
	char*	packname = (char *)SvPV_nolen(ST(0))
;
	char*	filename = (char *)SvPV_nolen(ST(1))
;
	char*	mode;
	Bio__DB__HTS__VCFfile	RETVAL;

	if (items < 3)
	    mode = "r";
	else {
	    mode = (char *)SvPV_nolen(ST(2))
;
	}
#line 1376 "lib/Bio/DB/HTS.xs"
      RETVAL = bcf_open(filename, mode);
#line 3164 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::VCFfile", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCFfile_header_read); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCFfile_header_read)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "vfile");
    {
	Bio__DB__HTS__VCFfile	vfile;
#line 1385 "lib/Bio/DB/HTS.xs"
        bcf_hdr_t* h;
#line 3186 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__VCF__Header	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCFfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    vfile = INT2PTR(Bio__DB__HTS__VCFfile,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCFfile::header_read",
			"vfile", "Bio::DB::HTS::VCFfile")
;
#line 1387 "lib/Bio/DB/HTS.xs"
        h = bcf_hdr_read(vfile);
        RETVAL = h;
#line 3201 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::VCF::Header", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCFfile_read1); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCFfile_read1)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "vfile, header");
    {
	Bio__DB__HTS__VCFfile	vfile;
	Bio__DB__HTS__VCF__Header	header;
#line 1398 "lib/Bio/DB/HTS.xs"
        bcf1_t *rec;
#line 3224 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__VCF__Row	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCFfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    vfile = INT2PTR(Bio__DB__HTS__VCFfile,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCFfile::read1",
			"vfile", "Bio::DB::HTS::VCFfile")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCFfile::read1",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1400 "lib/Bio/DB/HTS.xs"
        rec = bcf_init();
        if ( bcf_read(vfile, header, rec) == 0 )
        {
            bcf_unpack(rec, BCF_UN_ALL) ;
            RETVAL = rec ;
        }
        else
        {
            XSRETURN_EMPTY;
        }
#line 3257 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::VCF::Row", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCFfile_num_variants); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCFfile_num_variants)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "packname, filename");
    {
	char*	packname = (char *)SvPV_nolen(ST(0))
;
	char*	filename = (char *)SvPV_nolen(ST(1))
;
#line 1420 "lib/Bio/DB/HTS.xs"
        int n_records = 0;
        vcfFile* vfile;
        bcf_hdr_t* h;
        bcf1_t *rec;
#line 3285 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;
#line 1425 "lib/Bio/DB/HTS.xs"
        vfile = bcf_open(filename, "r");
        h = bcf_hdr_read(vfile);
        rec = bcf_init();

        //loop through all the lines but don't do anything with them
        while(bcf_read(vfile, h, rec) == 0)
        {
            ++n_records;
        }
        bcf_destroy(rec);
        bcf_hdr_destroy(h);
        bcf_close(vfile) ;
        RETVAL = newSViv(n_records);
#line 3301 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCFfile_vcf_close); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCFfile_vcf_close)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "vfile");
    {
	Bio__DB__HTS__VCFfile	vfile;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCFfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    vfile = INT2PTR(Bio__DB__HTS__VCFfile,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCFfile::vcf_close",
			"vfile", "Bio::DB::HTS::VCFfile")
;
#line 1447 "lib/Bio/DB/HTS.xs"
        bcf_close(vfile);
#line 3329 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Header_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Header_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "h");
    {
	Bio__DB__HTS__VCF__Header	h;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    h = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"Bio::DB::HTS::VCF::Header::DESTROY",
			"h")
;
#line 1455 "lib/Bio/DB/HTS.xs"
        bcf_hdr_destroy(h);
#line 3355 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Header_version); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Header_version)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "header");
    {
	Bio__DB__HTS__VCF__Header	header;
#line 1461 "lib/Bio/DB/HTS.xs"
#line 3370 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Header::version",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1462 "lib/Bio/DB/HTS.xs"
     RETVAL = newSVpv(bcf_hdr_get_version(header),0) ;
#line 3384 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Header_num_samples); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Header_num_samples)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "header");
    {
	Bio__DB__HTS__VCF__Header	header;
#line 1471 "lib/Bio/DB/HTS.xs"
#line 3401 "lib/Bio/DB/HTS.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Header::num_samples",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1472 "lib/Bio/DB/HTS.xs"
     RETVAL = bcf_hdr_nsamples(header) ;
#line 3416 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Header_get_sample_names); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Header_get_sample_names)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "header");
    {
	Bio__DB__HTS__VCF__Header	header;
#line 1481 "lib/Bio/DB/HTS.xs"
        int nsamples = 0 ;
        int i ;
        AV *av_ref;
#line 3435 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Header::get_sample_names",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1485 "lib/Bio/DB/HTS.xs"
        av_ref = newAV();
        nsamples = bcf_hdr_nsamples(header) ;
        for (i=0 ; i<nsamples ; i++)
        {
            SV *sv_ref = newSVpv(header->samples[i], 0);
            av_push(av_ref, sv_ref);
        }
        RETVAL = newRV_noinc((SV*)av_ref);
#line 3456 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Header_num_seqnames); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Header_num_seqnames)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "header");
    {
	Bio__DB__HTS__VCF__Header	header;
#line 1500 "lib/Bio/DB/HTS.xs"
        int nseq = 0 ;
#line 3474 "lib/Bio/DB/HTS.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Header::num_seqnames",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1502 "lib/Bio/DB/HTS.xs"
     bcf_hdr_seqnames(header, &nseq);
     RETVAL = nseq;
#line 3490 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Header_get_seqnames); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Header_get_seqnames)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "header");
    {
	Bio__DB__HTS__VCF__Header	header;
#line 1512 "lib/Bio/DB/HTS.xs"
        int nseq = 0 ;
        const char **seqnames ;
        int i = 0 ;
        AV *av_ref = newAV() ;
#line 3510 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Header::get_seqnames",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1517 "lib/Bio/DB/HTS.xs"
        seqnames = bcf_hdr_seqnames(header, &nseq);
        for (i = 0; i < nseq; i++)
        {
            SV *sv_ref = newSVpv(seqnames[i], 0);
            av_push(av_ref, sv_ref);
        }
        free(seqnames) ;
        RETVAL = newRV_noinc((SV*)av_ref);
#line 3531 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_print); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_print)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "row, header");
    {
	Bio__DB__HTS__VCF__Row	row;
	Bio__DB__HTS__VCF__Header	header;
#line 1539 "lib/Bio/DB/HTS.xs"
     int i ;
#line 3550 "lib/Bio/DB/HTS.c"

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::print",
			"row", "Bio::DB::HTS::VCF::Row")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::print",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1541 "lib/Bio/DB/HTS.xs"
     printf("\nVCF data line:\n");
     printf("chromosome:%s\t", bcf_hdr_id2name(header,row->rid));
     printf("position:%d\t", (row->pos+1));
     printf("QUAL:%f\t", row->qual);
     printf("ID:%s\t", row->d.id );
     printf("REF:%s\n", row->d.als);
     printf("Num Alleles:%d\n", row->n_allele-1);
     for( i=1 ; i<row->n_allele ; i++ )
     {
       printf("ALT[%d]=%s\t", i, row->d.allele[i]);
     }
     printf("\nNum Filters:%d\n", row->d.n_flt);

#line 3585 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_chromosome); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_chromosome)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "row, header");
    {
	Bio__DB__HTS__VCF__Row	row;
	Bio__DB__HTS__VCF__Header	header;
#line 1564 "lib/Bio/DB/HTS.xs"
#line 3601 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::chromosome",
			"row", "Bio::DB::HTS::VCF::Row")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::chromosome",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1565 "lib/Bio/DB/HTS.xs"
     RETVAL = newSVpv(bcf_hdr_id2name(header,row->rid),0) ;
#line 3625 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_position); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_position)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "row");
    {
	Bio__DB__HTS__VCF__Row	row;
#line 1574 "lib/Bio/DB/HTS.xs"
#line 3642 "lib/Bio/DB/HTS.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::position",
			"row", "Bio::DB::HTS::VCF::Row")
;
#line 1575 "lib/Bio/DB/HTS.xs"
     RETVAL = row->pos+1;
#line 3657 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_quality); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_quality)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "row");
    {
	Bio__DB__HTS__VCF__Row	row;
#line 1583 "lib/Bio/DB/HTS.xs"
#line 3673 "lib/Bio/DB/HTS.c"
	float	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::quality",
			"row", "Bio::DB::HTS::VCF::Row")
;
#line 1584 "lib/Bio/DB/HTS.xs"
     RETVAL = row->qual;
#line 3688 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_id); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_id)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "row");
    {
	Bio__DB__HTS__VCF__Row	row;
#line 1593 "lib/Bio/DB/HTS.xs"
#line 3704 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::id",
			"row", "Bio::DB::HTS::VCF::Row")
;
#line 1594 "lib/Bio/DB/HTS.xs"
     RETVAL = newSVpv(row->d.id, 0) ;
#line 3718 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_reference); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_reference)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "row");
    {
	Bio__DB__HTS__VCF__Row	row;
#line 1602 "lib/Bio/DB/HTS.xs"
#line 3735 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::reference",
			"row", "Bio::DB::HTS::VCF::Row")
;
#line 1603 "lib/Bio/DB/HTS.xs"
     RETVAL = newSVpv(row->d.als, 0) ;
#line 3749 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_num_alleles); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_num_alleles)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "row");
    {
	Bio__DB__HTS__VCF__Row	row;
#line 1612 "lib/Bio/DB/HTS.xs"
#line 3766 "lib/Bio/DB/HTS.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::num_alleles",
			"row", "Bio::DB::HTS::VCF::Row")
;
#line 1613 "lib/Bio/DB/HTS.xs"
     RETVAL = row->n_allele-1 ;
#line 3781 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_alleles); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_alleles)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "row");
    {
	Bio__DB__HTS__VCF__Row	row;
#line 1622 "lib/Bio/DB/HTS.xs"
     int i;
     AV *av_ref;
#line 3799 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_alleles",
			"row", "Bio::DB::HTS::VCF::Row")
;
#line 1625 "lib/Bio/DB/HTS.xs"
     av_ref = newAV();
     for (i = 1; i < row->n_allele; ++i) {
        SV *sv_ref = newSVpv(row->d.allele[i], 0);
        av_push(av_ref, sv_ref);
     }
     RETVAL = newRV_noinc((SV*)av_ref);
#line 3818 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_num_filters); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_num_filters)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "row");
    {
	Bio__DB__HTS__VCF__Row	row;
#line 1638 "lib/Bio/DB/HTS.xs"
#line 3835 "lib/Bio/DB/HTS.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::num_filters",
			"row", "Bio::DB::HTS::VCF::Row")
;
#line 1639 "lib/Bio/DB/HTS.xs"
     RETVAL = row->d.n_flt ;
#line 3850 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_has_filter); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_has_filter)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "row, header, filter");
    {
	Bio__DB__HTS__VCF__Row	row;
	Bio__DB__HTS__VCF__Header	header;
	char*	filter = (char *)SvPV_nolen(ST(2))
;
#line 1649 "lib/Bio/DB/HTS.xs"
#line 3869 "lib/Bio/DB/HTS.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::has_filter",
			"row", "Bio::DB::HTS::VCF::Row")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::has_filter",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1650 "lib/Bio/DB/HTS.xs"
     RETVAL = bcf_has_filter(header,row,filter) ;
#line 3894 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_is_snp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_is_snp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "row");
    {
	Bio__DB__HTS__VCF__Row	row;
#line 1659 "lib/Bio/DB/HTS.xs"
#line 3910 "lib/Bio/DB/HTS.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::is_snp",
			"row", "Bio::DB::HTS::VCF::Row")
;
#line 1660 "lib/Bio/DB/HTS.xs"
     RETVAL = bcf_is_snp(row) ;
#line 3925 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_variant_type); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_variant_type)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "row, allele_index");
    {
	Bio__DB__HTS__VCF__Row	row;
	int	allele_index = (int)SvIV(ST(1))
;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_variant_type",
			"row", "Bio::DB::HTS::VCF::Row")
;
#line 1670 "lib/Bio/DB/HTS.xs"
     RETVAL = bcf_get_variant_type(row, allele_index);
#line 3956 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_info_type); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_info_type)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "row, header, id");
    {
	Bio__DB__HTS__VCF__Row	row;
	Bio__DB__HTS__VCF__Header	header;
	char*	id = (char *)SvPV_nolen(ST(2))
;
#line 1681 "lib/Bio/DB/HTS.xs"
      bcf_info_t* info ;
#line 3976 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_info_type",
			"row", "Bio::DB::HTS::VCF::Row")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_info_type",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1683 "lib/Bio/DB/HTS.xs"
      info = bcf_get_info(header, row, id);
      if( info == NULL )
      {
        RETVAL = newSVpv("",0);
      }
      else
      {
        switch( info->type )
        {
          case BCF_BT_FLOAT:
               RETVAL = newSVpv("Float",0);
               break ;
          case BCF_BT_NULL:
               RETVAL = newSVpv("Flag",0);
               break ;
          case BCF_BT_CHAR:
               RETVAL = newSVpv("String",0);
               break ;
          default:
               RETVAL = newSVpv("Integer",0);
        }
      }
#line 4021 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_info); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_info)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "row, header, id");
    {
	Bio__DB__HTS__VCF__Row	row;
	Bio__DB__HTS__VCF__Header	header;
	char*	id = (char *)SvPV_nolen(ST(2))
;
#line 1715 "lib/Bio/DB/HTS.xs"
      bcf_info_t* info ;
      int i=0 ;
      int strlength=0 ;
      int* buf_i;
      float* buf_f;
      char* buf_c;
      AV* av_ref;
      int result;
#line 4049 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_info",
			"row", "Bio::DB::HTS::VCF::Row")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_info",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1724 "lib/Bio/DB/HTS.xs"
      info = bcf_get_info(header, row, id);
      if( info == NULL )
      {
          // info null, nothing to return
          RETVAL = newSVpv("ID_NOT_FOUND",0);
      }
      else
      {
        av_ref = newAV();
        if( info->type == BCF_BT_NULL )
        {
          buf_i = calloc(1, sizeof(int)) ;
          result = bcf_get_info_flag(header,row,id,&buf_i,&(info->len));
          if( result == 1 )
          {
            av_push(av_ref, newSViv(1));
          }
          else
          {
            av_push(av_ref, newSViv(0));
          }
          free(buf_i);
        }
        else if( info->type == BCF_BT_FLOAT )
        {
          buf_f = calloc(info->len, sizeof(float));
          result = bcf_get_info_float(header, row, id, &buf_f, &(info->len)) ;
          for( i=0 ; i<result ; i++ )
          {
            av_push(av_ref, newSVnv(buf_f[i])) ;
          }
          free(buf_f);
        }
        else if( info->type == BCF_BT_CHAR )
        {
          strlength = info->len+1 ;
          buf_c = calloc(strlength, sizeof(char));
          result = bcf_get_info_string(header,row,id,&buf_c,&strlength) ;
          buf_c[info->len] = '\0' ;
          av_push(av_ref, newSVpv(buf_c,0));
          free(buf_c);
        }
        else if( info->type == BCF_BT_INT32 )
        {
          buf_i = calloc(info->len, sizeof(int));
          result = bcf_get_info_int32(header, row, id, &buf_i, &(info->len)) ;
          for( i=0 ; i<result ; i++ )
          {
            av_push(av_ref, newSViv(buf_i[i])) ;
          }
          free(buf_i);
        }
        else if( info->type == BCF_BT_INT16 )
        {
          buf_i = calloc(info->len, sizeof(int));
          result = bcf_get_info_int32(header, row, id, &buf_i, &(info->len)) ;
          for( i=0 ; i<result ; i++ )
          {
            av_push(av_ref, newSViv(buf_i[i])) ;
          }
          free(buf_i);
        }
        else if( info->type == BCF_BT_INT8 )
        {
          buf_i = calloc(info->len, sizeof(int));
          result = bcf_get_info_int32(header, row, id, &buf_i, &(info->len)) ;
          for( i=0 ; i<result ; i++ )
          {
            av_push(av_ref, newSViv(buf_i[i])) ;
          }
          free(buf_i);
        }
        //return a reference to our array
        RETVAL = newRV_noinc((SV*)av_ref);
      }

#line 4148 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_format_type); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_format_type)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "row, header, id");
    {
	Bio__DB__HTS__VCF__Row	row;
	Bio__DB__HTS__VCF__Header	header;
	char*	id = (char *)SvPV_nolen(ST(2))
;
#line 1812 "lib/Bio/DB/HTS.xs"
      bcf_fmt_t* fmt ;
#line 4169 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_format_type",
			"row", "Bio::DB::HTS::VCF::Row")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_format_type",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1814 "lib/Bio/DB/HTS.xs"
      fmt = bcf_get_fmt(header, row, id);
      if( fmt == NULL )
      {
        RETVAL = newSVpv("",0);
      }
      else
      {
        switch( fmt->type )
        {
          case BCF_BT_FLOAT:
               RETVAL = newSVpv("Float",0);
               break ;
          case BCF_BT_CHAR:
               RETVAL = newSVpv("String",0);
               break ;
          default:
               RETVAL = newSVpv("Integer",0);
        }
      }
#line 4211 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_format); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_format)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "row, header, id");
    {
	Bio__DB__HTS__VCF__Row	row;
	Bio__DB__HTS__VCF__Header	header;
	char*	id = (char *)SvPV_nolen(ST(2))
;
#line 1843 "lib/Bio/DB/HTS.xs"
      bcf_fmt_t* fmt ;
      int i ;
      int* buf_i = NULL ;
      float* buf_f = NULL ;
      char* buf_c = NULL ;
      AV* av_ref;
      int ndst = 0 ;
      int result;
#line 4239 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_format",
			"row", "Bio::DB::HTS::VCF::Row")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_format",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1852 "lib/Bio/DB/HTS.xs"
      fmt = bcf_get_fmt(header, row, id);
      if( fmt == NULL )
      {
          // info null, nothing to return
          RETVAL = newSVpv("ID_NOT_FOUND",0);
      }
      else
      {
        av_ref = newAV();

        if( fmt->type == BCF_BT_FLOAT )
        {
          result = bcf_get_format_float(header, row, id, &buf_f, &ndst) ;
          for( i=0 ; i<ndst ; i++ )
          {
            av_push(av_ref, newSVnv(buf_f[i])) ;
          }
          free(buf_f);
        }
        else if( fmt->type == BCF_BT_CHAR )
        {
          result = bcf_get_format_char(header,row,id,&buf_c,&ndst) ;
          av_push(av_ref, newSVpv(buf_c, ndst+1));
          free(buf_c);
        }
        else if( fmt->type == BCF_BT_INT32 )
        {
          result = bcf_get_format_int32(header, row, id, &buf_i, &ndst) ;
          for( i=0 ; i<ndst ; i++ )
          {
            av_push(av_ref, newSViv(buf_i[i])) ;
          }
          free(buf_i);
        }
        else if( fmt->type == BCF_BT_INT16 )
        {
          result = bcf_get_format_int32(header, row, id, &buf_i, &ndst) ;
          for( i=0 ; i<ndst ; i++ )
          {
            av_push(av_ref, newSViv(buf_i[i])) ;
          }
          free(buf_i);
        }
        else if( fmt->type == BCF_BT_INT8 )
        {
          result = bcf_get_format_int32(header, row, id, &buf_i, &ndst) ;
          for( i=0 ; i<ndst ; i++ )
          {
            av_push(av_ref, newSViv(buf_i[i])) ;
          }
          free(buf_i);
        }
        //return a reference to our array
        RETVAL = newRV_noinc((SV*)av_ref);
      }

#line 4318 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_genotypes); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_genotypes)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "row, header");
    {
	Bio__DB__HTS__VCF__Row	row;
	Bio__DB__HTS__VCF__Header	header;
#line 1918 "lib/Bio/DB/HTS.xs"
      bcf_fmt_t* fmt ;
      int ngt ;
      int* gt_arr = NULL ;
      int ngt_arr = 0;
      AV* av_ref;
      int i=0 ;
#line 4342 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_genotypes",
			"row", "Bio::DB::HTS::VCF::Row")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_genotypes",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1925 "lib/Bio/DB/HTS.xs"
      av_ref = newAV();
      /* Note the VCF header type treats this as a String but BCF treats as an int */
      ngt = bcf_get_genotypes(header, row, &gt_arr, &ngt_arr);
      for( i=0 ; i<ngt_arr ; i++ )
      {
        av_push(av_ref, newSViv(gt_arr[i])) ;
      }
      free(gt_arr);
      RETVAL = newRV_noinc((SV*)av_ref);
#line 4374 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "row");
    {
	Bio__DB__HTS__VCF__Row	row;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"Bio::DB::HTS::VCF::Row::DESTROY",
			"row")
;
#line 1941 "lib/Bio/DB/HTS.xs"
      bcf_destroy(row);
#line 4402 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Sweep_sweep_open); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Sweep_sweep_open)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "filename");
    {
	char*	filename = (char *)SvPV_nolen(ST(0))
;
#line 1949 "lib/Bio/DB/HTS.xs"
        bcf_sweep_t* sweep;
#line 4419 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__VCF__Sweep	RETVAL;
#line 1951 "lib/Bio/DB/HTS.xs"
        sweep = bcf_sweep_init(filename);
        RETVAL = sweep;
#line 4424 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::VCF::Sweep", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Sweep_header_read); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Sweep_header_read)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sweep");
    {
	Bio__DB__HTS__VCF__Sweep	sweep;
#line 1960 "lib/Bio/DB/HTS.xs"
        bcf_hdr_t* h;
#line 4446 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__VCF__HeaderPtr	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Sweep")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sweep = INT2PTR(Bio__DB__HTS__VCF__Sweep,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Sweep::header_read",
			"sweep", "Bio::DB::HTS::VCF::Sweep")
;
#line 1962 "lib/Bio/DB/HTS.xs"
        h = bcf_sweep_hdr(sweep);
        RETVAL = h;
#line 4461 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::VCF::HeaderPtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Sweep_sweep_next); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Sweep_sweep_next)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sweep");
    {
	Bio__DB__HTS__VCF__Sweep	sweep;
#line 1971 "lib/Bio/DB/HTS.xs"
        bcf1_t* line;
#line 4483 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__VCF__RowPtr	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Sweep")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sweep = INT2PTR(Bio__DB__HTS__VCF__Sweep,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Sweep::sweep_next",
			"sweep", "Bio::DB::HTS::VCF::Sweep")
;
#line 1973 "lib/Bio/DB/HTS.xs"
        line = bcf_sweep_fwd(sweep);
        if( line )
        {
          RETVAL = line;
        }
        else
        {
          XSRETURN_EMPTY ;
        }
#line 4505 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::VCF::RowPtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Sweep_sweep_previous); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Sweep_sweep_previous)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sweep");
    {
	Bio__DB__HTS__VCF__Sweep	sweep;
#line 1989 "lib/Bio/DB/HTS.xs"
        bcf1_t* line;
#line 4527 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__VCF__RowPtr	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Sweep")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sweep = INT2PTR(Bio__DB__HTS__VCF__Sweep,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Sweep::sweep_previous",
			"sweep", "Bio::DB::HTS::VCF::Sweep")
;
#line 1991 "lib/Bio/DB/HTS.xs"
        line = bcf_sweep_bwd(sweep);
        if( line )
        {
          RETVAL = line;
        }
        else
        {
          XSRETURN_EMPTY ;
        }
#line 4549 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::VCF::RowPtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Sweep_sweep_close); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Sweep_sweep_close)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sweep");
    {
	Bio__DB__HTS__VCF__Sweep	sweep;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Sweep")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sweep = INT2PTR(Bio__DB__HTS__VCF__Sweep,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Sweep::sweep_close",
			"sweep", "Bio::DB::HTS::VCF::Sweep")
;
#line 2007 "lib/Bio/DB/HTS.xs"
        bcf_sweep_destroy(sweep);
#line 4581 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq_new)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "package, filename, mode=\"r\"");
    {
	char *	package = (char *)SvPV_nolen(ST(0))
;
	char *	filename = (char *)SvPV_nolen(ST(1))
;
	char *	mode;
	Bio__DB__HTS__Kseq	RETVAL;

	if (items < 3)
	    mode = "r";
	else {
	    mode = (char *)SvPV_nolen(ST(2))
;
	}
#line 2020 "lib/Bio/DB/HTS.xs"
      RETVAL = gzopen(filename, mode);
#line 4609 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Kseq", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq_newfh); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq_newfh)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "pack, fh, mode=\"r\"");
    {
	char *	pack = (char *)SvPV_nolen(ST(0))
;
	PerlIO*	fh = IoIFP(sv_2io(ST(1)))
;
	char *	mode;
	Bio__DB__HTS__Kseq	RETVAL;

	if (items < 3)
	    mode = "r";
	else {
	    mode = (char *)SvPV_nolen(ST(2))
;
	}
#line 2031 "lib/Bio/DB/HTS.xs"
      RETVAL = gzdopen(PerlIO_fileno(fh), mode);
#line 4643 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Kseq", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq_iterator); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq_iterator)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "fp");
    {
	Bio__DB__HTS__Kseq	fp;
	Bio__DB__HTS__Kseq__Iterator	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    fp = INT2PTR(Bio__DB__HTS__Kseq,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::iterator",
			"fp", "Bio::DB::HTS::Kseq")
;
#line 2040 "lib/Bio/DB/HTS.xs"
      RETVAL = kseq_init(fp);
#line 4676 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Kseq::Iterator", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "fp");
    {
	Bio__DB__HTS__Kseq	fp;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    fp = INT2PTR(Bio__DB__HTS__Kseq,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"Bio::DB::HTS::Kseq::DESTROY",
			"fp")
;
#line 2049 "lib/Bio/DB/HTS.xs"
      gzclose(fp);
#line 4708 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_new)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "package, fh");
    {
	char *	package = (char *)SvPV_nolen(ST(0))
;
	Bio__DB__HTS__Kseq	fh;
	Bio__DB__HTS__Kseq__Kstream	RETVAL;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::Kseq")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    fh = INT2PTR(Bio__DB__HTS__Kseq,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Kstream::new",
			"fh", "Bio::DB::HTS::Kseq")
;
#line 2059 "lib/Bio/DB/HTS.xs"
      RETVAL = ks_init(fh);
#line 4737 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Kseq::Kstream", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_begin); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_begin)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "kstr");
    {
	Bio__DB__HTS__Kseq__Kstream	kstr;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Kstream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    kstr = INT2PTR(Bio__DB__HTS__Kseq__Kstream,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Kstream::begin",
			"kstr", "Bio::DB::HTS::Kseq::Kstream")
;
#line 2068 "lib/Bio/DB/HTS.xs"
      RETVAL = kstr->begin;
#line 4771 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_end); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_end)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "kstr");
    {
	Bio__DB__HTS__Kseq__Kstream	kstr;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Kstream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    kstr = INT2PTR(Bio__DB__HTS__Kseq__Kstream,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Kstream::end",
			"kstr", "Bio::DB::HTS::Kseq::Kstream")
;
#line 2077 "lib/Bio/DB/HTS.xs"
      RETVAL = kstr->end;
#line 4800 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_is_eof); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_is_eof)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "kstr");
    {
	Bio__DB__HTS__Kseq__Kstream	kstr;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Kstream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    kstr = INT2PTR(Bio__DB__HTS__Kseq__Kstream,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Kstream::is_eof",
			"kstr", "Bio::DB::HTS::Kseq::Kstream")
;
#line 2086 "lib/Bio/DB/HTS.xs"
      RETVAL = kstr->is_eof;
#line 4829 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_buffer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_buffer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "kstr");
    {
	Bio__DB__HTS__Kseq__Kstream	kstr;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Kstream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    kstr = INT2PTR(Bio__DB__HTS__Kseq__Kstream,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Kstream::buffer",
			"kstr", "Bio::DB::HTS::Kseq::Kstream")
;
#line 2095 "lib/Bio/DB/HTS.xs"
      RETVAL = (char *)kstr->buf;
#line 4858 "lib/Bio/DB/HTS.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_fh); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_fh)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "kstr");
    {
	Bio__DB__HTS__Kseq__Kstream	kstr;
	Bio__DB__HTS__Kseq	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Kstream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    kstr = INT2PTR(Bio__DB__HTS__Kseq__Kstream,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Kstream::fh",
			"kstr", "Bio::DB::HTS::Kseq::Kstream")
;
#line 2104 "lib/Bio/DB/HTS.xs"
      RETVAL = kstr->f;
#line 4886 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Kseq", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "kstr");
    {
	Bio__DB__HTS__Kseq__Kstream	kstr;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    kstr = INT2PTR(Bio__DB__HTS__Kseq__Kstream,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"Bio::DB::HTS::Kseq::Kstream::DESTROY",
			"kstr")
;
#line 2113 "lib/Bio/DB/HTS.xs"
      ks_destroy(kstr);
#line 4918 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_next_seq_hash); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_next_seq_hash)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::next_seq_hash",
			"it", "Bio::DB::HTS::Kseq::Iterator")
;
#line 2122 "lib/Bio/DB/HTS.xs"
      HV * results;
#line 4945 "lib/Bio/DB/HTS.c"
#line 2124 "lib/Bio/DB/HTS.xs"
      results = (HV *)sv_2mortal((SV *)newHV());
      if (kseq_read(it) >= 0) {
          hv_stores(results, "name", newSVpvn(it->name.s, it->name.l));
          hv_stores(results, "desc", newSVpvn(it->comment.s, it->comment.l));
          hv_stores(results, "seq", newSVpvn(it->seq.s, it->seq.l));
          hv_stores(results, "qual", newSVpvn(it->qual.s, it->qual.l));
          RETVAL = newRV((SV *)results);
      } else {
          XSRETURN_UNDEF;
      }
#line 4957 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_next_seq); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_next_seq)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::next_seq",
			"it", "Bio::DB::HTS::Kseq::Iterator")
;
#line 2142 "lib/Bio/DB/HTS.xs"
    HV * results;
    HV * class_stash;
    SV * ref;
#line 4988 "lib/Bio/DB/HTS.c"
#line 2146 "lib/Bio/DB/HTS.xs"
    results = (HV *)sv_2mortal((SV *)newHV());
    class_stash = gv_stashpv("Bio::DB::HTS::Kseq::Record", 0);
    if (kseq_read(it) >= 0) {
        hv_stores(results, "name", newSVpvn(it->name.s, it->name.l));
        hv_stores(results, "desc", newSVpvn(it->comment.s, it->comment.l));
        hv_stores(results, "seq", newSVpvn(it->seq.s, it->seq.l));
        hv_stores(results, "qual", newSVpvn(it->qual.s, it->qual.l));
        ref = newRV((SV *)results);
        sv_bless(ref, class_stash);
        RETVAL = ref;
    } else {
        XSRETURN_UNDEF;
    }
#line 5003 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_read); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_read)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::read",
			"it", "Bio::DB::HTS::Kseq::Iterator")
;
#line 2167 "lib/Bio/DB/HTS.xs"
#line 5032 "lib/Bio/DB/HTS.c"
#line 2168 "lib/Bio/DB/HTS.xs"
      RETVAL = kseq_read(it);
#line 5035 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_rewind); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_rewind)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::rewind",
			"it", "Bio::DB::HTS::Kseq::Iterator")
;
#line 2177 "lib/Bio/DB/HTS.xs"
      /* kseq_rewind() doesn't completely rewind the file,
        just resets markers */
      kseq_rewind(it);
      /* use zlib to do so */
      gzrewind(it->f->f);
#line 5066 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_kstream); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_kstream)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;
	Bio__DB__HTS__Kseq__Kstream	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::kstream",
			"it", "Bio::DB::HTS::Kseq::Iterator")
;
#line 2188 "lib/Bio/DB/HTS.xs"
      RETVAL = it->f;
#line 5093 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Kseq::Kstream", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_name)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::name",
			"it", "Bio::DB::HTS::Kseq::Iterator")
;
#line 2197 "lib/Bio/DB/HTS.xs"
      RETVAL = it->name.s;
#line 5127 "lib/Bio/DB/HTS.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_comment); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_comment)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::comment",
			"it", "Bio::DB::HTS::Kseq::Iterator")
;
#line 2206 "lib/Bio/DB/HTS.xs"
      RETVAL = it->comment.s;
#line 5156 "lib/Bio/DB/HTS.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_seq); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_seq)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::seq",
			"it", "Bio::DB::HTS::Kseq::Iterator")
;
#line 2215 "lib/Bio/DB/HTS.xs"
      RETVAL = it->seq.s;
#line 5185 "lib/Bio/DB/HTS.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_qual); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_qual)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::qual",
			"it", "Bio::DB::HTS::Kseq::Iterator")
;
#line 2224 "lib/Bio/DB/HTS.xs"
      RETVAL = it->qual.s;
#line 5214 "lib/Bio/DB/HTS.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_last_char); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_last_char)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::last_char",
			"it", "Bio::DB::HTS::Kseq::Iterator")
;
#line 2233 "lib/Bio/DB/HTS.xs"
      RETVAL = it->last_char;
#line 5243 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"Bio::DB::HTS::Kseq::Iterator::DESTROY",
			"it")
;
#line 2242 "lib/Bio/DB/HTS.xs"
      kseq_destroy(it);
#line 5270 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Bio__DB__HTS); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Bio__DB__HTS)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        (void)newXSproto_portable("Bio::DB::HTS::Fai::load", XS_Bio__DB__HTS__Fai_load, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTS::Fai::DESTROY", XS_Bio__DB__HTS__Fai_DESTROY, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Fai::fetch", XS_Bio__DB__HTS__Fai_fetch, file, "$$$");
        newXS_deffile("Bio::DB::HTSfile::max_pileup_cnt", XS_Bio__DB__HTSfile_max_pileup_cnt);
        (void)newXSproto_portable("Bio::DB::HTSfile::is_remote", XS_Bio__DB__HTSfile_is_remote, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTSfile::open", XS_Bio__DB__HTSfile_open, file, "$$$");
        (void)newXSproto_portable("Bio::DB::HTSfile::DESTROY", XS_Bio__DB__HTSfile_DESTROY, file, "$");
        newXS_deffile("Bio::DB::HTSfile::index_build", XS_Bio__DB__HTSfile_index_build);
        (void)newXSproto_portable("Bio::DB::HTSfile::index_load", XS_Bio__DB__HTSfile_index_load, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTSfile::header_read", XS_Bio__DB__HTSfile_header_read, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTSfile::header_write", XS_Bio__DB__HTSfile_header_write, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTSfile::read1", XS_Bio__DB__HTSfile_read1, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTSfile::write1", XS_Bio__DB__HTSfile_write1, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::new", XS_Bio__DB__HTS__Alignment_new, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::DESTROY", XS_Bio__DB__HTS__Alignment_DESTROY, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::tid", XS_Bio__DB__HTS__Alignment_tid, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::pos", XS_Bio__DB__HTS__Alignment_pos, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::calend", XS_Bio__DB__HTS__Alignment_calend, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::cigar2qlen", XS_Bio__DB__HTS__Alignment_cigar2qlen, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::qual", XS_Bio__DB__HTS__Alignment_qual, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::flag", XS_Bio__DB__HTS__Alignment_flag, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::n_cigar", XS_Bio__DB__HTS__Alignment_n_cigar, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::l_qseq", XS_Bio__DB__HTS__Alignment_l_qseq, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::qseq", XS_Bio__DB__HTS__Alignment_qseq, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::_qscore", XS_Bio__DB__HTS__Alignment__qscore, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::mtid", XS_Bio__DB__HTS__Alignment_mtid, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::mpos", XS_Bio__DB__HTS__Alignment_mpos, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::isize", XS_Bio__DB__HTS__Alignment_isize, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::l_aux", XS_Bio__DB__HTS__Alignment_l_aux, file, "$;$");
        newXS_deffile("Bio::DB::HTS::Alignment::aux", XS_Bio__DB__HTS__Alignment_aux);
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::aux_get", XS_Bio__DB__HTS__Alignment_aux_get, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::aux_keys", XS_Bio__DB__HTS__Alignment_aux_keys, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::data", XS_Bio__DB__HTS__Alignment_data, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::data_len", XS_Bio__DB__HTS__Alignment_data_len, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::m_data", XS_Bio__DB__HTS__Alignment_m_data, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::qname", XS_Bio__DB__HTS__Alignment_qname, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::paired", XS_Bio__DB__HTS__Alignment_paired, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::proper_pair", XS_Bio__DB__HTS__Alignment_proper_pair, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::unmapped", XS_Bio__DB__HTS__Alignment_unmapped, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::munmapped", XS_Bio__DB__HTS__Alignment_munmapped, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::reversed", XS_Bio__DB__HTS__Alignment_reversed, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::mreversed", XS_Bio__DB__HTS__Alignment_mreversed, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::cigar", XS_Bio__DB__HTS__Alignment_cigar, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Header::new", XS_Bio__DB__HTS__Header_new, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Header::n_targets", XS_Bio__DB__HTS__Header_n_targets, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Header::target_name", XS_Bio__DB__HTS__Header_target_name, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Header::target_len", XS_Bio__DB__HTS__Header_target_len, file, "$");
        newXS_deffile("Bio::DB::HTS::Header::text", XS_Bio__DB__HTS__Header_text);
        (void)newXSproto_portable("Bio::DB::HTS::Header::parse_region", XS_Bio__DB__HTS__Header_parse_region, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Header::view1", XS_Bio__DB__HTS__Header_view1, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTS::Header::DESTROY", XS_Bio__DB__HTS__Header_DESTROY, file, "$");
        newXS_deffile("Bio::DB::HTS::Index::fetch", XS_Bio__DB__HTS__Index_fetch);
        newXS_deffile("Bio::DB::HTS::Index::pileup", XS_Bio__DB__HTS__Index_pileup);
        newXS_deffile("Bio::DB::HTS::Index::coverage", XS_Bio__DB__HTS__Index_coverage);
        newXS_deffile("Bio::DB::HTS::Index::DESTROY", XS_Bio__DB__HTS__Index_DESTROY);
        newXS_deffile("Bio::DB::HTS::Pileup::qpos", XS_Bio__DB__HTS__Pileup_qpos);
        newXS_deffile("Bio::DB::HTS::Pileup::pos", XS_Bio__DB__HTS__Pileup_pos);
        newXS_deffile("Bio::DB::HTS::Pileup::indel", XS_Bio__DB__HTS__Pileup_indel);
        newXS_deffile("Bio::DB::HTS::Pileup::level", XS_Bio__DB__HTS__Pileup_level);
        newXS_deffile("Bio::DB::HTS::Pileup::is_del", XS_Bio__DB__HTS__Pileup_is_del);
        newXS_deffile("Bio::DB::HTS::Pileup::is_refskip", XS_Bio__DB__HTS__Pileup_is_refskip);
        newXS_deffile("Bio::DB::HTS::Pileup::is_head", XS_Bio__DB__HTS__Pileup_is_head);
        newXS_deffile("Bio::DB::HTS::Pileup::is_tail", XS_Bio__DB__HTS__Pileup_is_tail);
        newXS_deffile("Bio::DB::HTS::Pileup::b", XS_Bio__DB__HTS__Pileup_b);
        newXS_deffile("Bio::DB::HTS::Pileup::alignment", XS_Bio__DB__HTS__Pileup_alignment);
        newXS_deffile("Bio::DB::HTS::Tabix::tbx_open", XS_Bio__DB__HTS__Tabix_tbx_open);
        newXS_deffile("Bio::DB::HTS::Tabix::tbx_close", XS_Bio__DB__HTS__Tabix_tbx_close);
        newXS_deffile("Bio::DB::HTS::Tabix::tbx_query", XS_Bio__DB__HTS__Tabix_tbx_query);
        newXS_deffile("Bio::DB::HTS::Tabix::tbx_header", XS_Bio__DB__HTS__Tabix_tbx_header);
        newXS_deffile("Bio::DB::HTS::Tabix::tbx_seqnames", XS_Bio__DB__HTS__Tabix_tbx_seqnames);
        newXS_deffile("Bio::DB::HTS::Tabix::Iterator::tbx_iter_next", XS_Bio__DB__HTS__Tabix__Iterator_tbx_iter_next);
        newXS_deffile("Bio::DB::HTS::Tabix::Iterator::tbx_iter_free", XS_Bio__DB__HTS__Tabix__Iterator_tbx_iter_free);
        (void)newXSproto_portable("Bio::DB::HTS::VCFfile::open", XS_Bio__DB__HTS__VCFfile_open, file, "$$$");
        newXS_deffile("Bio::DB::HTS::VCFfile::header_read", XS_Bio__DB__HTS__VCFfile_header_read);
        newXS_deffile("Bio::DB::HTS::VCFfile::read1", XS_Bio__DB__HTS__VCFfile_read1);
        (void)newXSproto_portable("Bio::DB::HTS::VCFfile::num_variants", XS_Bio__DB__HTS__VCFfile_num_variants, file, "$$$");
        newXS_deffile("Bio::DB::HTS::VCFfile::vcf_close", XS_Bio__DB__HTS__VCFfile_vcf_close);
        newXS_deffile("Bio::DB::HTS::VCF::Header::DESTROY", XS_Bio__DB__HTS__VCF__Header_DESTROY);
        newXS_deffile("Bio::DB::HTS::VCF::Header::version", XS_Bio__DB__HTS__VCF__Header_version);
        newXS_deffile("Bio::DB::HTS::VCF::Header::num_samples", XS_Bio__DB__HTS__VCF__Header_num_samples);
        newXS_deffile("Bio::DB::HTS::VCF::Header::get_sample_names", XS_Bio__DB__HTS__VCF__Header_get_sample_names);
        newXS_deffile("Bio::DB::HTS::VCF::Header::num_seqnames", XS_Bio__DB__HTS__VCF__Header_num_seqnames);
        newXS_deffile("Bio::DB::HTS::VCF::Header::get_seqnames", XS_Bio__DB__HTS__VCF__Header_get_seqnames);
        newXS_deffile("Bio::DB::HTS::VCF::Row::print", XS_Bio__DB__HTS__VCF__Row_print);
        newXS_deffile("Bio::DB::HTS::VCF::Row::chromosome", XS_Bio__DB__HTS__VCF__Row_chromosome);
        newXS_deffile("Bio::DB::HTS::VCF::Row::position", XS_Bio__DB__HTS__VCF__Row_position);
        newXS_deffile("Bio::DB::HTS::VCF::Row::quality", XS_Bio__DB__HTS__VCF__Row_quality);
        newXS_deffile("Bio::DB::HTS::VCF::Row::id", XS_Bio__DB__HTS__VCF__Row_id);
        newXS_deffile("Bio::DB::HTS::VCF::Row::reference", XS_Bio__DB__HTS__VCF__Row_reference);
        newXS_deffile("Bio::DB::HTS::VCF::Row::num_alleles", XS_Bio__DB__HTS__VCF__Row_num_alleles);
        newXS_deffile("Bio::DB::HTS::VCF::Row::get_alleles", XS_Bio__DB__HTS__VCF__Row_get_alleles);
        newXS_deffile("Bio::DB::HTS::VCF::Row::num_filters", XS_Bio__DB__HTS__VCF__Row_num_filters);
        newXS_deffile("Bio::DB::HTS::VCF::Row::has_filter", XS_Bio__DB__HTS__VCF__Row_has_filter);
        newXS_deffile("Bio::DB::HTS::VCF::Row::is_snp", XS_Bio__DB__HTS__VCF__Row_is_snp);
        newXS_deffile("Bio::DB::HTS::VCF::Row::get_variant_type", XS_Bio__DB__HTS__VCF__Row_get_variant_type);
        newXS_deffile("Bio::DB::HTS::VCF::Row::get_info_type", XS_Bio__DB__HTS__VCF__Row_get_info_type);
        newXS_deffile("Bio::DB::HTS::VCF::Row::get_info", XS_Bio__DB__HTS__VCF__Row_get_info);
        newXS_deffile("Bio::DB::HTS::VCF::Row::get_format_type", XS_Bio__DB__HTS__VCF__Row_get_format_type);
        newXS_deffile("Bio::DB::HTS::VCF::Row::get_format", XS_Bio__DB__HTS__VCF__Row_get_format);
        newXS_deffile("Bio::DB::HTS::VCF::Row::get_genotypes", XS_Bio__DB__HTS__VCF__Row_get_genotypes);
        newXS_deffile("Bio::DB::HTS::VCF::Row::DESTROY", XS_Bio__DB__HTS__VCF__Row_DESTROY);
        newXS_deffile("Bio::DB::HTS::VCF::Sweep::sweep_open", XS_Bio__DB__HTS__VCF__Sweep_sweep_open);
        newXS_deffile("Bio::DB::HTS::VCF::Sweep::header_read", XS_Bio__DB__HTS__VCF__Sweep_header_read);
        newXS_deffile("Bio::DB::HTS::VCF::Sweep::sweep_next", XS_Bio__DB__HTS__VCF__Sweep_sweep_next);
        newXS_deffile("Bio::DB::HTS::VCF::Sweep::sweep_previous", XS_Bio__DB__HTS__VCF__Sweep_sweep_previous);
        newXS_deffile("Bio::DB::HTS::VCF::Sweep::sweep_close", XS_Bio__DB__HTS__VCF__Sweep_sweep_close);
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::new", XS_Bio__DB__HTS__Kseq_new, file, "$$$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::newfh", XS_Bio__DB__HTS__Kseq_newfh, file, "$$$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::iterator", XS_Bio__DB__HTS__Kseq_iterator, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::DESTROY", XS_Bio__DB__HTS__Kseq_DESTROY, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Kstream::new", XS_Bio__DB__HTS__Kseq__Kstream_new, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Kstream::begin", XS_Bio__DB__HTS__Kseq__Kstream_begin, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Kstream::end", XS_Bio__DB__HTS__Kseq__Kstream_end, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Kstream::is_eof", XS_Bio__DB__HTS__Kseq__Kstream_is_eof, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Kstream::buffer", XS_Bio__DB__HTS__Kseq__Kstream_buffer, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Kstream::fh", XS_Bio__DB__HTS__Kseq__Kstream_fh, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Kstream::DESTROY", XS_Bio__DB__HTS__Kseq__Kstream_DESTROY, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::next_seq_hash", XS_Bio__DB__HTS__Kseq__Iterator_next_seq_hash, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::next_seq", XS_Bio__DB__HTS__Kseq__Iterator_next_seq, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::read", XS_Bio__DB__HTS__Kseq__Iterator_read, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::rewind", XS_Bio__DB__HTS__Kseq__Iterator_rewind, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::kstream", XS_Bio__DB__HTS__Kseq__Iterator_kstream, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::name", XS_Bio__DB__HTS__Kseq__Iterator_name, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::comment", XS_Bio__DB__HTS__Kseq__Iterator_comment, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::seq", XS_Bio__DB__HTS__Kseq__Iterator_seq, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::qual", XS_Bio__DB__HTS__Kseq__Iterator_qual, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::last_char", XS_Bio__DB__HTS__Kseq__Iterator_last_char, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::DESTROY", XS_Bio__DB__HTS__Kseq__Iterator_DESTROY, file, "$");
#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

